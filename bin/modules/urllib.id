###
# Name        : urllib
# Author      : @SplittyDev
# Description : An easy to use module for working with urls
###

use reverse, hex, len, printf, sprintf from corelib;

###
### Public functions
###

func normalize_url (url) {
  input = url
  lower_url = input.toLower ()
  protocol = _get_url_protocol (lower_url)
  base = _get_url_base (lower_url)
  base = _opt_url_base (base)
  tail = _get_url_tail (lower_url)
  tail = _opt_url_tail (tail)
  return _build_url (protocol, base, tail)
}

func get_url_protocol (url) {
  url = normalize_url (url)
  return _get_url_protocol (url)
}

func get_url_base (url) {
  url = normalize_url (url)
  return _get_url_base (url)
}

func get_url_tail (url) {
  url = normalize_url (url)
  return _get_url_tail (url)
}

func get_url_port (url) {
  url = normalize_url (url)
  return _get_url_port (url)
}

func parse_query (url) {
  tail = get_url_tail (url)
  return _parse_query (tail)
}

###
### Private functions
###

func _get_url_protocol (url) {
  return url.substr (0, url.indexOf ("://"))
}

func _get_url_base (url) {
  start = url.indexOf ("://") + 3
  middle = url.substr (start)
  if (middle.contains ("/")) {
    last_slash = len(middle) - reverse (middle).indexOf ("/")
    middle = middle.substr (0, last_slash - 1)
  }
  return middle
}

func _get_url_tail (url) {
  start = url.substr (url.indexOf ("://") + 3)
  if (start.contains ("/")) {
    last_slash = len(start) - reverse (start).indexOf ("/")
    return start.substr (last_slash)
  }
  else
    return ""
}

func _get_url_port (url) {
  url = _get_url_base (url)
  if (!url.contains (":"))
    return 80
  port = url.substr (url.indexOf (":") + 1)
  return toInt (port)
}

func _opt_url_base (url) {
  if (!url.contains (":"))
    return url
  base = url.substr (0, url.indexOf (":"))
  port = url.substr (url.indexOf (":") + 1)
  if (port == "80")
    return base
  return url
}

func _opt_url_tail (url) {
  n = 0
  inc = lambda () => {
    prevn = n
    n = n + 1
    return hex (prevn)
  }
  lookup = hashMap ()
  n = 32
  lookup[" "]   = inc ()
  lookup["!"]   = inc ()
  lookup["\""]  = inc ()
  lookup["#"]   = inc ()
  lookup["$"]   = inc ()
  lookup["%"]   = inc ()
  #lookup["&"]  = inc ()
  lookup["'"]   = inc ()
  lookup["("]   = inc ()
  lookup[")"]   = inc ()
  lookup["*"]   = inc ()
  lookup["+"]   = inc ()
  lookup[","]   = inc ()
  lookup["-"]   = inc ()
  #lookup["."]  = inc ()
  #lookup["/"]  = inc ()
  n = 58
  lookup[":"]   = inc ()
  lookup[";"]   = inc ()
  lookup["<"]   = inc ()
  #lookup["="]  = inc ()
  lookup[">"]   = inc ()
  #lookup["?"]  = inc ()
  lookup["@"]   = inc ()
  n = 91
  lookup["["]   = inc ()
  lookup["\\"]  = inc ()
  lookup["]"]   = inc ()
  lookup["^"]   = inc ()
  lookup["_"]   = inc ()
  lookup["`"]   = inc ()
  i = 0
  buf = ""
  while (i < len (url)) {
    if (lookup.contains (url[i]))
      buf += sprintf ("%{}", lookup[url[i]])
    else
      buf += url[i]
    i = i + 1
  }
  return buf
}

func _build_url (protocol, base, tail) {
  return sprintf ("{}://{}/{}", (protocol, base, tail))
}

func _parse_query (tail) {
  dict = hashMap ()
  skip = "?&="
  i = 0;
  if (tail[0] == "?")
    tail = tail.substr (1)
  lines = tail.split ("&")
  foreach (line in lines) {
    if (line.contains ("=")) {
      index = line.indexOf ("=")
      dict[line.substr (0, index)] = line.substr (index + 1)
    }
    else
      dict[line] = null
  }
  return dict
}
