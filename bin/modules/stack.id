###
# Name        : stack
# Author      : @SplittyDev
# Description : Stack data structure
# Please add yourself as author if you make changes
###

use * from core

class Stack {
  func Stack (self) {
    self.store = List ()
    self.iter_index = 0
  }

  func push (self, val) {
    self.store.add (val)
  }

  func pop (self) {
    if (len (self.store) == 0)
      raise ("There are no elements on the stack!")
    tmp = reverse (self.store)
    val = tmp[0]
    tmp.removeAt (0)
    self.store = reverse (tmp)
    return val
  }

  # So.. this is REALLY hacky.
  # The lookahead parameter is optional.
  func peek (self, params args) {
    lookahead = 0
    if (len (args) > 0 && type (args[0]) == "Int")
      lookahead = args[0]
    if (lookahead >= len (self.store))
      raise (sprintf ("Index out of range: Can't peek item {} of {}",
        lookahead + 1, len (self.store)))
    return reverse (self.store)[lookahead]
  }

  func _iterReset (self) {
    self.iter_index = len (self.store) - 1
  }

  func _iterMoveNext (self) {
    self.iter_index -= 1
    return self.iter_index >= 0
  }

  func _iterGetNext (self) {
    return self.store[self.iter_index]
  }
}

# This is probably the hackiest iodine class
# that currently exists
class TypedStack {
  func TypedStack (self, t) {
    # This is pretty interesting
    # I call it the pseudo-inheritance hack.
    self.typeDef.name = "Stack"
    self.stack = Stack ()
    self.store = self.stack.store
    t = Str(t).toLower()
    if (t == "str")
      self.t = Str
    else if (t == "int")
      self.t = Int
    else if (t == "list")
      self.t = List
    else
      raise (sprintf ("Unsupported type: {}", t))
  }

  func push (self, val) {
    self.stack.push (self.t (val))
  }

  func pop (self) {
    return self.stack.pop ()
  }

  func peek (self, params args) {
    if (len (args) > 0)
      return self.stack.peek (args[0])
    return self.stack.peek ()
  }

  func _iterReset (self) {
    self.stack._iterReset ()
  }

  func _iterMoveNext (self) {
    return self.stack._iterMoveNext ()
  }

  func _iterGetNext (self) {
    return self.stack._iterGetnext ()
  }
}
