###
# Name        : testing
# Author      : @SplittyDev
# Description : Iodine unit testing library
# Please add yourself as author if you make changes
###

use type, repr, len, printf from core

class assert {
  func assert (self) {
    self.passed = 0
    self.failed = 0
    self.history = list ()
    self.hooks = list ()
    self.last = null
  }

  func add (self, action) {
    self.hooks.add (action)
  }

  ###
  ### Test runner
  ###

  func run (self) {
    print ("============[ Running Unit tests ]============")
    last = null
    i = 0
    foreach (hook in self.hooks) {
      hook (self)
      if (len (self.history) != 0)
        self.last = self.history[len (self.history) - 1]
      if (last != self.last) {
        last = self.last
        msg = "FAIL"
        if (last.passed)
          msg = "PASS"
        printf ("Test {}: {}\n\t{}", (i, last.msg, msg))
        if (!last.passed)
          printf ("\tExpect: {}\n\tActual: {}",
            (repr (last.expected), repr (last.result)))
        i = i + 1
      }
    }
  }

  ###
  ### Assertion functions
  ###

  func _eq (self, expected, actual, msg) {
    if (self.use_list_compare (expected, actual)) {
      tmp = self.list_compare (expected, actual)
      expected = true
      actual = tmp
    }
    if (expected == actual)
      self.pass (expected, actual, msg)
    else
      self.fail (expected, actual, msg)
  }

  func _neq (self, expected, actual, msg) {
    if (self.use_list_compare (expected, actual)) {
      tmp = self.list_compare (expected, actual)
      expected = true
      actual = tmp
    }
    if (expected != actual)
      self.pass (expected, actual, msg)
    else
      self.fail (expected, actual, msg)
  }

  ###
  ### Assertion wrappers
  ###

  func eq (self, expected, actual, msg) {
    self._eq (expected, actual, msg)
  }

  func neq (self, expected, actual, msg) {
    self._neq (expected, actual, msg)
  }

  func pass (self, expected, result, msg) {
    self.history.add (testResult (expected, result, true, msg))
  }

  func fail (self, expected, result, msg) {
    self.history.add (testResult (expected, result, false, msg))
  }

  ###
  ### Tricky bits
  ###

  func use_list_compare (self, expected, actual) {
    lookup = {"List", "Tuple"}
    if (lookup.contains (expected) && lookup.contains (actual))
      return true
    return false
  }

  func list_compare (self, expected, actual) {
    i = 0
    if (len (expected) != len (actual))
      return false
    while (i < len (expected)) {
      if (expected[i] != actual[i])
        return false
      i = i + 1
    }
    return true
  }
}

class testResult {
  func testResult (self, expected, result, passed, msg) {
    self.expected = expected
    self.result = result
    self.passed = passed
    self.msg = msg
  }
}
