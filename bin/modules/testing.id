###
# Name        : testing
# Author      : @SplittyDev
# Description : Iodine unit testing library
# Please add yourself as author if you make changes
###

use repr, len, printf from core

class assert {
  func assert (self) {
    self.passed = 0
    self.failed = 0
    self.history = list ()
    self.hooks = list ()
    self.last = null
    self.lock = false
    self.PASS = "PASS"
    self.FAIL = "FAIL"
    self.SKIP = "SKIP"
    self.INDETERMINATE = "INDETERMINATE"
  }

  func add (self, action) {
    self.hooks.add (action)
  }

  ###
  ### Test runner
  ###

  func run (self) {
    print ("============[ Running Unit tests ]============")
    last = null
    i = 0
    foreach (hook in self.hooks) {
      hook (self)
      if (len (self.history) != 0)
        self.last = self.history[len (self.history) - 1]
      if (last != self.last) {
        last = self.last
        msg = last.state
        printf ("Test {}: {}\n\t{}", (i, last.msg, msg))
        if (last.state == self.FAIL)
          printf ("\tExpect: {}\n\tActual: {}",
            (repr (last.expected), repr (last.result)))
      }
      else {
        printf ("Test {}:\n\t{}", (i, self.INDETERMINATE))
      }
      i = i + 1
      self.lock = false
    }
  }

  ###
  ### Assertion functions
  ###

  func _eq (self, expected, actual, msg) {
    if (self.should_list_compare (expected, actual)) {
      tmp = self.list_compare (expected, actual)
      expected = true
      actual = tmp
    }
    if (expected == actual)
      self.pass (expected, actual, msg)
    self.fail (expected, actual, msg)
  }

  func _neq (self, expected, actual, msg) {
    if (self.should_list_compare (expected, actual)) {
      tmp = self.list_compare (expected, actual)
      expected = true
      actual = tmp
    }
    if (expected != actual)
      self.pass (expected, actual, msg)
    self.fail (expected, actual, msg)
  }

  func _gt (self, x, y, msg) {
    if (x > y)
      self.pass (true, true, msg)
    self.fail (true, false, msg)
  }

  func _lt (self, x, y, msg) {
    if (x < y)
      self.pass (true, true, msg)
    self.fail (true, false, msg)
  }

  func _instanceof (self, obj, tdef) {
    if (core.type (obj) == tdef)
      self.pass (true, true, msg)
    self.fail (true, false, msg)
  }

  func _notinstanceof (self, obj, tdef) {
    if (core.type (obj) != tdef)
      self.pass (true, true, msg)
    self.fail (true, false, msg)
  }

  ###
  ### Assertion wrappers
  ###

  func eq (self, expected, actual, msg) {
    self._eq (expected, actual, msg)
  }

  func equals (self, expected, actual, msg) {
    self._eq (expected, actual, msg)
  }

  func neq (self, expected, actual, msg) {
    self._neq (expected, actual, msg)
  }

  func notEquals (self, expected, actual, msg) {
    self._neq (expected, actual, msg)
  }

  func gt (self, x, y, msg)  {
    self._gt (x, y, msg)
  }

  func greater (self, x, y, msg) {
    self._gt (x, y, msg)
  }

  func lt (self, x, y, msg) {
    self._lt (x, y, msg)
  }

  func less (self, x, y, msg) {
    self._lt (x, y, msg)
  }

  func type (self, obj, tdef) {
    self._instanceof (obj, tdef)
  }

  func instanceOf (self, obj, tdef) {
    self._instanceof (obj, tdef)
  }

  func notInstanceOf (self, obj, tdef) {
    self._notinstanceof (obj, tdef)
  }

  func pass (self, expected, result, msg) {
    if (!self.lock) {
      self.history.add (testResult (expected, result, self.PASS, msg))
      self.lock = true
    }
  }

  func fail (self, expected, result, msg) {
    if (!self.lock) {
      self.history.add (testResult (expected, result, self.FAIL, msg))
      self.lock = true
    }
  }

  func skip (self, msg) {
    if (!self.lock) {
      self.history.add (testResult (null, null, self.SKIP, msg))
      self.lock = true
    }
  }

  ###
  ### Tricky bits
  ###

  func should_list_compare (self, expected, actual) {
    if ((core.type (expected) == "List" && core.type (actual) == "List")
         || (core.type (expected) == "Tuple" && core.type (actual) == "Tuple"))
      return true
    return false
  }

  func list_compare (self, expected, actual) {
    i = 0
    if (len (expected) != len (actual))
      return false
    while (i < len (expected)) {
      if (expected[i] != actual[i])
        return false
      i = i + 1
    }
    return true
  }
}

class testResult {
  func testResult (self, expected, result, state, msg) {
    self.expected = expected
    self.result = result
    self.state = state
    self.msg = msg
  }
}
