/**
 * Module for creating documentation from iodine objects
 * @author GruntTheDivine
 */
 
use inspect;
use __builtins__;

contract DocumentationFormatter {
    func formatDoc (documentation);
}

enum ElementType {
    FUNCTION = 0,
    CLASS = 1,
    CONTRACT = 2,
    TRAIT = 3,
    ENUM = 4,
    MODULE = 5,
}

class Element {
    func Element (self, ElementType, str) {
        self.ElementType = ElementType;
        self.str = str;
        self.description = "";
        self.params = [];
    }
    
    func parseDocumentation (self, docstr) {
        _parseDoc (self, docstr.split ('\n'));
    }
}

class FuncElement extends Element {
    func FuncElement (self, name, item) {
        super (ElementType.FUNCTION, item.__doc__);
        self.name = name;
        self.params = [];
        self.parseDocumentation (item.__doc__);
    }
}

class ClassElement extends Element {
    func ClassElement (self, name, c) {
        super (ElementType.CLASS, c.__doc__);
        self.name = name;
        self.params = [];
        self.parseDocumentation (c.__doc__);
        self.items = [];
        _compileAttributes (self.items, inspect.getmembers (c));
    }
}

class ParamTag {
    func ParamTag (self, name, type, description, optional, kwarg) {
        self.name = name;
        self.type = type;
        self.description = description;
        self.optional = optional;
        self.kwarg = kwarg;
    }
    
    func __str__ (self) {
        return self.name;
    }
}

func _parseDoc (obj, docLines) {
    description = StringBuffer ();
    for (str in docLines) {
        if (str.startswith ("@param")) {
            obj.params.append (_parseParamTag (str, false, false));
        }
        else if (str.startswith ("@optional")) {
            obj.params.append (_parseParamTag (str, true, false));
        }
        else if (str.startswith ("@kwarg")) {
            obj.params.append (_parseParamTag (str, false, true));
        }
        else {
            description.append (str);
        }
    }
    
    obj.description = Str (description);
}

func _parseParamTag (line, optional, kwarg) {
    tokens = line.split (' ');
    
    if (len (line) > 2) {
        name = tokens [1];
        type = null;
        description = null;
        
        if (tokens [2] == ":") {
            type = tokens [3];
            description = " ".join (tokens [4::1]);
        } else if (tokens [2].startswith (":")) {
            type = tokens [2].substr (1);
            description = " ".join (tokens [3::1]);
        } else if (name.contains (":")) {
            name = tokens [1].substr (0, name.find (":"));
            type = tokens [1].substr (tokens [1].find (":") + 1);
            description = " ".join (tokens [2::1]);
        } else {
            description = " ".join (tokens [2::1]);
        }
        
        return ParamTag (name, type, description, optional, kwarg);
    }
    raise Exception ("Invalid param tag");
}

class HtmlFormatter {
    func HtmlFormatter (self) {
        self.indentLevel = 0;
    }
    
    func format (self, items, output) {
        for (item in items) {
            output.append ("[#{item.name}](##{item.name}) "); 
        }
        
        output.append ("\n\n");
        
        for (item in items) {
            self.formatItem (item, output);
        }
    }
    
    func formatItem (self, item, output) {
        given (item.ElementType) {
            when ElementType.FUNCTION {
                self.formatFunc (item, output);
            }
            when ElementType.CLASS {
                self.formatClass (item, output);
            }
            when ElementType.Contract {
                
            }
            when ElementType.TRAIT {
                
            }
            when ElementType.MODULE {
                
            }
        }
    }
    
    func formatFunc (self, doc, output) {
        output.append ("<strong><code>#{doc.name}</code></strong> (");
        output.append (", ".join (doc.params));
        output.append (")<br>\n");
        output.append ("<div style='position: relative; padding-left:50px;'>\n");
        output.append (doc.description);
        output.append ("<br>\n");
        output.append ("<table>");
        for (param in doc.params) {
            output.append ("<tr>");
            output.append ("<td><code>#{param.name}</code></td>");
            output.append ("<td>#{param.description}</td>\n");
            output.append ("</tr></br>");
        }
        output.append ("</table>");
        output.append ("</div>");
        output.append ("<br/>");
    }
    
    func formatClass (self, doc, output) {
        output.append ("class <strong><code>#{doc.name}</code></strong> (");
        output.append (", ".join (doc.params));
        output.append (")<br>\n");
        output.append ("<div style='position: relative; padding-left:50px;'>\n");
        output.append (doc.description);
        output.append ("<br>\n");
        output.append ("<table>");
        for (param in doc.params) {
            output.append ("<tr>");
            output.append ("<td><code>#{param.name}</code></td>");
            output.append ("<td>#{param.description}</td>\n");
            output.append ("</tr></br>");
        }

        
        output.append ("</table><br>");
                
        for (item in doc.items) {
            self.formatItem (item, output);
        }
        
        output.append ("</div>");
        output.append ("<br/>");
    }
    
    func formatContract (self, doc, output) {
        
    }
}

func compiledoc (obj, *args) {
    items = [];
    
    _compileAttributes (items, inspect.getmembers (obj));
    
    items = sort (items, lambda (p) => p.name);
    
    return items;
}

func _compileAttributes (items, attrs) {
    for (name, attr in attrs) {
        if (inspect.hasattribute (attr, "__doc__")) {
            if (inspect.ismethod (attr) || inspect.isbuiltin (attr)) {
                items.append (FuncElement (name, attr));
            }
            if (inspect.istype (attr)) {
                items.append (ClassElement (name, attr));
            }
        }
    }
}
