use socket;

_statusCodes = {
    200 : "200 OK",
    201 : "201 Created",
    202 : "202 Accepted",
    203 : "203 Non-Authoritative Information",
    204 : "204 No Content",
    205 : "205 Reset Content",
    206 : "206 Partial Content",
    300 : "300 Multiple Choices",
    301 : "301 Moved Permanently",
    302 : "302 Found",
    303 : "303 See Other",
    304 : "304 Not Modified",
    305 : "305 Use Proxy",
    306 : "306 Switch Proxy",
    307 : "307 Temporary Redirect",
    308 : "308 Permanent Redirect",
    400 : "400 Bad Request",
    401 : "401 Unauthorized",
    402 : "402 Payment Required",
    403 : "403 Forbidden",
    404 : "404 Not Found",
    405 : "405 Method Not Allowed",
    406 : "406 Not Acceptable",
    407 : "407 Proxy Authentication Required",
    408 : "408 Request Timeout",
    409 : "408 Request Timeout",
    410 : "410 Gone",
    411 : "411 Length Required",
    412 : "412 Precondition Failed",
    413 : "413 Payload Too Large",
    414 : "414 URI Too Long",
    415 : "415 Unsupported Media Type",
    416 : "416 Range Not Satisfiable",
    417 : "417 Expectation Failed",
    418 : "418 I'm a teapot",
    421 : "421 Misdirected Request",
    422 : "422 Unprocessable Entity",
    423 : "423 Locked",
    424 : "424 Failed Dependency",
    426 : "426 Upgrade Required",
    428 : "428 Precondition Required",
    429 : "429 Too Many Requests",
    431 : "431 Request Header Fields Too Large",
    451 : "451 Unavailable For Legal Reasons"
};

/*
 * Parse a query string and return a dict
 */
func parseQueryString (queryString) {
    if (queryString == null) {
        return {};
    }
    pairs = queryString.split("&");
    if (pairs[0] == "") {
        return {};
    }
    query_dict = {};
    for (pair in pairs) {
        pair_items = pair.split("=");
        query_dict[pair_items[0]] = unescapeQueryItem (pair_items[1]);
    }
    return query_dict;
}

func unescapeQueryItem (item) {
    item = item.replace ("+", " ");
    i = 0;
    accum = "";
    while (i < len (item)) {
        if (item [i] == "%") {
            ch = item [i + 1] + item [i + 2];
            accum += chr (Int (ch, 16));
            i += 3;
        } else {
            accum += item [i];
            i += 1;
        }
    }
    return accum;
}

/**
 * HTTP Request
 */
class HttpRequest {
    func HttpRequest (self) {
        self.parameters = {};
        self.postData = {};
    }
}

/**
 * HTTP Response 
 */
class HttpResponse {
    func HttpResponse (self) {
        self.headers = {};
        self._response = StringBuffer ();
        self.statusCode = 200;
    }
    
    /**
     * Writes a string of data to the response stream
     * @param data The data to be written
     */
    func write (self, data) {
        self._response.append (data);
    }
    
    /**
     * Writes a string of data to the response, appending
     * a new line to the data
     * @param line The line to be written
     */
    func writeln (self, line) {
        self._response.append (line + "\r\n");
    }
}

/**
 * Base HTTP Server class
 */
class BaseHttpServer {

    func BaseHttpServer (self) {
        self.routes = {};
        foo = HttpRequest ();
        self.sock = socket.socket (socket.SOCK_STREAM, socket.PROTO_TCP)
    }
    
    func handleRequest (self, response, request) {
        response.statusCode = 418;
    }
    
    func listen (self, host, port) {
        self.host =     host
        self.address =  host
        self.port =     port
        self.sock.bind (self.address, self.port)
        self.sock.listen (100)
        
        while (true) {
            client = self.sock.accept ();
            self._acceptConnection (client);
        }
    }
    
    func _acceptConnection (self, client) {
        stream = client.getStream ();
        
        req = stream.readln ();
        headers = {};
        do {
            val = stream.readln ().trim ();
            
            if (val.trim () == "") {
                break;
            }
            
            field = val.split (':');
            if (len (field) == 2) {
                headers [field [0].trim ()]= field [1].trim ();
            }
        } while (client.getBytesAvailable () > 0);
        
        self._serveRequest (stream, req, headers);
        stream.close ();
        client.close ();
    }
    
    func _serveRequest (self, client, request, headers) {
        reqArgs = request.split (' ');
        
        requestType = reqArgs [0];
        
        reqObj = HttpRequest ();
        
        content = "";
        
        if (headers.contains ("Content-Length")) {
            n = headers ["Content-Length"];
            content = client.read (Int (n));
        }
        
        given (requestType) {
            when "GET" {
                if (reqArgs [0].contains ("?")) {
                    path = reqArgs [0].substr (0, reqArgs [0].find ("?"));
                    queryStr = reqArgs [0].substr (reqArgs [0].find ("?") + 1);
                    reqObj.parameters = parseQueryString (queryStr);
                }
                self.servePage (client, reqArgs [1], reqObj);
            }
            when "POST" {
                if (reqArgs [0].contains ("?")) {
                    path = reqArgs [0].substr (0, reqArgs [0].find ("?"));
                    queryStr = reqArgs [0].substr (reqArgs [0].find ("?") + 1);
                    reqObj.parameters = parseQueryString (queryStr);
                } 
                reqObj.postData = parseQueryString (content);
                self.servePage (client, reqArgs [1], reqObj);
            }
            
        }
    }
    
    func servePage (self, stream, path, requestObj) {
        headers = {
            "Content-Encoding" : "UTF-8",
            "Content-Type" : "text/html; charset=UTF-8",
            "Connection" : "close"
        };        
        
        content = "";
        requestObj.url = path;
        
        resp = HttpResponse ();
        
        self.handleRequest (resp, requestObj);
        
        content = Str (resp._response);
        
        status = _statusCodes [resp.statusCode];
        
        stream.write ("HTTP/1.1 #{status}\r\n");
        
        headers ["Content-Length"] = Str (len (content));
        
        for (key in headers) {
            stream.write (key);
            stream.write (": ");
            stream.write (headers [key]);
            stream.write ("\r\n");
        }
        
        
        stream.write ("\r\n");
        stream.write (content);
        stream.flush ();
    }
}


class SimpleHttpServer : BaseHttpServer {
    
    func SimpleHttpServer (self) {
        super ();
        self._routes = {};
        self._defaultHandler = self.notFoundHandler;
    }
    
    func notFoundHandler (self, response, request) {
        response.statusCode = 404;
        response.writeln ("<html><head>");
        response.writeln ("<title>404 Not Found</title>");
        response.writeln ("</head><body>");
        response.writeln ("<h1>Not Found</h1>");
        response.writeln ("<p>The requested URL #{request.url} was not found on this server.</p>");
        response.writeln ("</body></html>");
    }
    
    func handle (self, route, handleFunc) {
        self._routes.set (route, handleFunc);
    }
    
    func handleRequest (self, response, request) {
        if (self._routes.contains (request.url)) {
            self._routes [request.url] (response, request);
        } else {
            self.notFoundHandler (response, request);
        }
    }
}
