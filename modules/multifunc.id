/**
 * Provides classes for implementing function overloading
 * @module multifunc
 * @author GruntTheDivine
 */


/**
 * Overload exception is raised when a suitable overload is not found in a
 * overloaded multifunc
 */
class OverloadException : Exception {
    func OverloadException (self) {
        super ("No suitable overload was found!");
    }   
}

/**
 * Represents a multifunction where signatures are defined based on argument
 * count
 */
class MultiFunc {
    func MultiFunc (self) {
        self._dispatchTable = {};
        self._default = lambda (args) {
            raise OverloadException ();
        };
    }

    /**
     * Defines a function that will be invoked when this multifunc instance
     * is called matching this signature
     * @param method Method callback
     * @param argc How many arguments are required for callback
     */
    func define (self, method, argc) {
        self._dispatchTable [argc] = method;   
    }

    /**
     * Defines a default callback which will be invoked if no suitable
     * overload was found.
     * @param meth Method Callback
     */
    func defineDefault (self, meth) {
        self._default = meth;
    }

    func __invoke__ (self, *args) {
        size = len (args);
        if (self._dispatchTable.contains (size)) {
            self._dispatchTable [size] (*args);
        } else {
            self._default (args);
        }   
    }
}

/**
 * Represents a multifunction where signatures are defined based on argument
 * types
 */
class TypedMultiFunc {
    class TypedOverload {
        func TypedOverload (self, method, types) {
            self._types = types;
            self._method = method;
        }


        func isMatch (self, args) {
            if (len (args) != len (self._types)) {
                return false;
            }

            for (i in 0 .. len (args)) {
                if (args [i] isnot self._types [i]) {
                    return false;
                }
            }

            return true;
        }
    }

    func TypedMultiFunc (self) {
        self._dispatchTable = [];
        self._default = lambda (args) {
            raise OverloadException ();
        }
    }
    
    /**
     * Defines an overload which will be invoked if the arguments passed to
     * this multifunction matches the types described in type list
     * @param method Method callback
     * @param typeList A list of types that define this signature
     */
    func define (self, method, *typeList) {
        self._dispatchTable.add (TypedMultiFunc.TypedOverload (method, typeList));
    }

    func __invoke__ (self, *args) {
        matches = filter (self._dispatchTable, lambda (p) => p.isMatch (args));
        if (len (matches) == 0) {
            self._default (args);
        } else {
            matches [0]._method (*args);
        }
    }
}
